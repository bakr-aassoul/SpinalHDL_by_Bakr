<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Einleitung &#8212; SpinalHDL  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to SpinalHDL Documention" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="einleitung">
<h1><span class="section-number">1. </span>Einleitung<a class="headerlink" href="#einleitung" title="Link to this heading">¶</a></h1>
<section id="motivation">
<h2><span class="section-number">1.1. </span>Motivation<a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h2>
<p>SpinalHDL wurde entwickelt, um die Produktivitäts- und Wartbarkeitsprobleme klassischer Hardwarebeschreibungssprachen (HDLs) wie VHDL und Verilog zu beheben. Es ermöglicht Entwicklern, wiederverwendbare und skalierbare digitale Designs in einer modernen, typgesicherten Umgebung zu erstellen – durch die Integration in die Programmiersprache Scala.</p>
</section>
<section id="uberblick-uber-traditionelle-hdls-vhdl-verilog">
<h2><span class="section-number">1.2. </span>Überblick über traditionelle HDLs (VHDL/Verilog)<a class="headerlink" href="#uberblick-uber-traditionelle-hdls-vhdl-verilog" title="Link to this heading">¶</a></h2>
<p>Traditionelle HDLs wie VHDL und Verilog wurden in den 1980er Jahren entwickelt. Obwohl sie bis heute Standard sind, haben sie erhebliche Nachteile:</p>
<ul class="simple">
<li><p><strong>Geringe Abstraktion:</strong> Strukturelle Wiederverwendung und Parametrisierung sind schwierig.</p></li>
<li><p><strong>Schlechte Fehlerdiagnose:</strong> Kompilierungsfehler liefern oft kryptische Fehlermeldungen.</p></li>
<li><p><strong>Statischer Code:</strong> Keine Möglichkeit zur dynamischen Erzeugung von Komponenten.</p></li>
<li><p><strong>Mangelnde Integration moderner Softwarepraktiken:</strong> Keine Unit-Tests, keine IDE-Integration auf hohem Niveau.</p></li>
</ul>
</section>
<section id="warum-die-abkehr-sinnvoll-ist">
<h2><span class="section-number">1.3. </span>Warum die Abkehr sinnvoll ist<a class="headerlink" href="#warum-die-abkehr-sinnvoll-ist" title="Link to this heading">¶</a></h2>
<p>Moderne Hardwareentwicklungsprojekte profitieren von den Prinzipien der Softwareentwicklung:</p>
<ul class="simple">
<li><p>Wiederverwendbarkeit durch Module</p></li>
<li><p>Testbarkeit durch Simulation und automatisierte Tests</p></li>
<li><p>Abstraktion durch objektorientierte und funktionale Programmierung</p></li>
</ul>
<p>SpinalHDL vereint diese Stärken mit der Möglichkeit, dennoch synthetisierbaren VHDL- oder Verilog-Code zu generieren.</p>
</section>
</section>
<hr class="docutils" />
<section id="grundlagen-von-spinalhdl">
<h1><span class="section-number">2. </span>Grundlagen von SpinalHDL<a class="headerlink" href="#grundlagen-von-spinalhdl" title="Link to this heading">¶</a></h1>
<p>SpinalHDL ist eine Hardwarebeschreibungssprache, die als <strong>Domain Specific Language (DSL)</strong> in <strong>Scala</strong> implementiert ist. Sie bietet gegenüber VHDL und Verilog eine moderne, typensichere und modulare Beschreibung von Schaltungen.</p>
<section id="variablendeklaration-in-spinalhdl">
<h2><span class="section-number">2.1. </span>Variablendeklaration in SpinalHDL<a class="headerlink" href="#variablendeklaration-in-spinalhdl" title="Link to this heading">¶</a></h2>
<p>Die wichtigsten Typen zur Signalbeschreibung:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Typ</p></th>
<th class="head"><p>Beschreibung</p></th>
<th class="head"><p>Beispiel</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Bool</span></code></p></td>
<td><p>Ein einzelnes Bit (true/false)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">myBit</span> <span class="pre">=</span> <span class="pre">Bool()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UInt</span></code></p></td>
<td><p>Unsigned Integer (z. B. 8 Bit)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">count</span> <span class="pre">=</span> <span class="pre">UInt(8</span> <span class="pre">bits)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SInt</span></code></p></td>
<td><p>Signed Integer</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">SInt(16</span> <span class="pre">bits)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Bits</span></code></p></td>
<td><p>Bit-Vektor ohne Interpretation</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">raw</span> <span class="pre">=</span> <span class="pre">Bits(4</span> <span class="pre">bits)</span></code></p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>In SpinalHDL beschreibt <code class="docutils literal notranslate"><span class="pre">val</span></code> eine <strong>konstante Referenz auf ein Signalobjekt</strong> – nicht das Signal selbst wie in Verilog.</p>
</div></blockquote>
</section>
<section id="signale-vs-register">
<h2><span class="section-number">2.2. </span>Signale vs. Register<a class="headerlink" href="#signale-vs-register" title="Link to this heading">¶</a></h2>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">       </span><span class="c1">// Kombinatorisch (wire)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w">  </span><span class="c1">// Getaktetes Register</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Reg(...)</span></code> erzeugt ein Flip-Flop (Register) mit Initialwert:</p></li>
</ul>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="steuerstrukturen">
<h2><span class="section-number">2.3. </span>Steuerstrukturen<a class="headerlink" href="#steuerstrukturen" title="Link to this heading">¶</a></h2>
<p>Wie in Scala aber spezialisiert für Hardwarelogik:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// true-Zweig</span>
<span class="p">}</span><span class="w"> </span><span class="n">elsewhen</span><span class="p">(</span><span class="n">otherCond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// anderer Zweig</span>
<span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// fallback-Zweig</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Beispiel:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span>
<span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="bundles-schnittstellen">
<h2><span class="section-number">2.4. </span>Bundles (Schnittstellen)<a class="headerlink" href="#bundles-schnittstellen" title="Link to this heading">¶</a></h2>
<p>Ein <code class="docutils literal notranslate"><span class="pre">Bundle</span></code> ist wie ein <code class="docutils literal notranslate"><span class="pre">struct</span></code>:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">done</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alle Signale im Bundle sind typisiert (<code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>).</p>
</section>
<section id="vektoren-und-arrays">
<h2><span class="section-number">2.5. </span>Vektoren und Arrays<a class="headerlink" href="#vektoren-und-arrays" title="Link to this heading">¶</a></h2>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">4</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
</pre></div>
</div>
<p>Vektoren erlauben z. B. Busse, Speicher, Registergruppen.</p>
</section>
<section id="komponentenstruktur">
<h2><span class="section-number">2.6. </span>Komponentenstruktur<a class="headerlink" href="#komponentenstruktur" title="Link to this heading">¶</a></h2>
<p>Eine Hardwareeinheit (Modul) ist eine Klasse, die von <code class="docutils literal notranslate"><span class="pre">Component</span></code> erbt:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyModule</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="top-level-mit-verilog-ausgabe">
<h2><span class="section-number">2.7. </span>Top-Level mit Verilog-Ausgabe<a class="headerlink" href="#top-level-mit-verilog-ausgabe" title="Link to this heading">¶</a></h2>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">MyModuleVerilog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">MyModule</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="typisches-verhalten-vs-vhdl">
<h2><span class="section-number">2.8. </span>Typisches Verhalten vs. VHDL<a class="headerlink" href="#typisches-verhalten-vs-vhdl" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Aktion</p></th>
<th class="head"><p>VHDL</p></th>
<th class="head"><p>SpinalHDL</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Signal zuweisen</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Wenn-Bedingung</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">if...elsif...else</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">when...elsewhen...otherwise</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Register mit Reset</p></td>
<td><p>Prozess mit Reset</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Reg(...)</span> <span class="pre">init(...)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Strukturierte I/Os</p></td>
<td><p>Record / Port Map</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Bundle</span></code>, <code class="docutils literal notranslate"><span class="pre">in/out</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="besonderheiten">
<h2><span class="section-number">2.9. </span>Besonderheiten<a class="headerlink" href="#besonderheiten" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>stark typisiert</strong> – viele Fehler werden vom Compiler erkannt</p></li>
<li><p><strong>parametrisierbar</strong> – Bausteine können generisch sein</p></li>
<li><p><strong>simulationsfähig</strong> – direkt in Scala testbar</p></li>
<li><p><strong>Verilog/VHDL-Ausgabe</strong> – leicht integrierbar</p></li>
</ul>
</section>
<section id="tl-dr-fur-anfanger">
<h2><span class="section-number">2.10. </span>TL;DR für Anfänger<a class="headerlink" href="#tl-dr-fur-anfanger" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Du willst …</p></th>
<th class="head"><p>… dann nutze</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1 Bit Signal</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Bool()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>8 Bit Zähler</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Reg(UInt(8</span> <span class="pre">bits))</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Multiplexer</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Mux(sel,</span> <span class="pre">a,</span> <span class="pre">b)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Verzweigung</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">when</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Interface</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Bundle</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="struktur-und-aufbau-eines-spinalhdl-projekts">
<h1><span class="section-number">3. </span>Struktur und Aufbau eines SpinalHDL-Projekts<a class="headerlink" href="#struktur-und-aufbau-eines-spinalhdl-projekts" title="Link to this heading">¶</a></h1>
<section id="ordnerstruktur">
<h2><span class="section-number">3.1. </span>Ordnerstruktur<a class="headerlink" href="#ordnerstruktur" title="Link to this heading">¶</a></h2>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>my-spinal-project/
├── build.sbt
├── src/
│   ├── main/
│   │   └── scala/           // SpinalHDL-Komponenten
│   └── test/
│       └── scala/           // Simulation und Unit-Tests
├── generated/               // generierter Verilog/VHDL
└── README.md
</pre></div>
</div>
</section>
<section id="entwicklungsumgebung">
<h2><span class="section-number">3.2. </span>Entwicklungsumgebung<a class="headerlink" href="#entwicklungsumgebung" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>IDE:</strong> IntelliJ IDEA mit Scala-Plugin</p></li>
<li><p><strong>Build-Tool:</strong> sbt (Scala Build Tool)</p></li>
<li><p><strong>Simulation:</strong> Verilator oder GHDL</p></li>
</ul>
</section>
<section id="beispiel-kommando">
<h2><span class="section-number">3.3. </span>Beispiel-Kommando<a class="headerlink" href="#beispiel-kommando" title="Link to this heading">¶</a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span>compile
sbt<span class="w"> </span>run
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="vorteile-von-spinalhdl-gegenuber-traditionellen-hdls">
<h1><span class="section-number">4. </span>Vorteile von SpinalHDL gegenüber traditionellen HDLs<a class="headerlink" href="#vorteile-von-spinalhdl-gegenuber-traditionellen-hdls" title="Link to this heading">¶</a></h1>
<section id="syntax-und-typsicherheit">
<h2><span class="section-number">4.1. </span>Syntax und Typsicherheit<a class="headerlink" href="#syntax-und-typsicherheit" title="Link to this heading">¶</a></h2>
<p>SpinalHDL basiert auf Scala und profitiert von einer modernen, stark typisierten Syntax. Typfehler oder Verbindungsprobleme werden bereits zur Kompilierzeit erkannt, was typische Laufzeitfehler klassischer HDLs verhindert.</p>
</section>
<section id="abstraktion-und-wiederverwendbarkeit">
<h2><span class="section-number">4.2. </span>Abstraktion und Wiederverwendbarkeit<a class="headerlink" href="#abstraktion-und-wiederverwendbarkeit" title="Link to this heading">¶</a></h2>
<p>Mit Vererbung, generischen Klassen und parametrisierten Modulen können Komponenten einfach angepasst und wiederverwendet werden. Schleifen, Funktionen, Bedingungen und sogar Fabriken für Komponenten sind möglich.</p>
</section>
<section id="fehlerdiagnose">
<h2><span class="section-number">4.3. </span>Fehlerdiagnose<a class="headerlink" href="#fehlerdiagnose" title="Link to this heading">¶</a></h2>
<p>Fehlermeldungen in SpinalHDL enthalten vollständige Stacktraces aus Scala und zeigen direkt auf die Quelle des Problems  z. B. eine ungültige Zuweisung oder ein Signal, das mehrfach getrieben wird.</p>
</section>
<section id="simulation-debugging">
<h2><span class="section-number">4.4. </span>Simulation &amp; Debugging<a class="headerlink" href="#simulation-debugging" title="Link to this heading">¶</a></h2>
<p>Durch die Integration mit Scala kann SpinalHDL direkt in der JVM simuliert werden. Mit <code class="docutils literal notranslate"><span class="pre">SimConfig</span></code> und <code class="docutils literal notranslate"><span class="pre">ScalaTest</span></code> lassen sich präzise, wiederholbare Testcases erstellen.</p>
</section>
</section>
<hr class="docutils" />
<section id="entwicklungsworkflow">
<h1><span class="section-number">5. </span>Entwicklungsworkflow<a class="headerlink" href="#entwicklungsworkflow" title="Link to this heading">¶</a></h1>
<p>In SpinalHDL folgt ein typischer Designprozess drei Phasen:</p>
<ol class="arabic simple">
<li><p><strong>Komponentenbeschreibung</strong> (Design)</p></li>
<li><p><strong>Simulation &amp; Verifikation</strong> (Test)</p></li>
<li><p><strong>Codegenerierung</strong> (Export in Verilog/VHDL)</p></li>
</ol>
<section id="komponentenbeschreibung">
<h2><span class="section-number">5.1. </span>Komponentenbeschreibung<a class="headerlink" href="#komponentenbeschreibung" title="Link to this heading">¶</a></h2>
<p>Hier wird das gewünschte Verhalten in einem Modul (Component) beschrieben.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Adder</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="erklarung">
<h3><span class="section-number">5.1.1. </span>Erklärung :<a class="headerlink" href="#erklarung" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Adder</span> <span class="pre">extends</span> <span class="pre">Component</span></code>: definiert eine neue SpinalHDL-Komponente.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">Bundle</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>: legt die I/O-Schnittstelle fest.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>: 8-Bit Eingänge (z. B. zwei Summanden)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code>: 8-Bit Ausgang (Summe)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">io.result</span> <span class="pre">:=</span> <span class="pre">io.a</span> <span class="pre">+</span> <span class="pre">io.b</span></code>: beschreibt die Logik: Addition von <code class="docutils literal notranslate"><span class="pre">a</span></code> und <code class="docutils literal notranslate"><span class="pre">b</span></code>, das Ergebnis wird ausgegeben.</p></li>
</ul>
<p><strong>Das ist reine Kombinatorik</strong>, kein Register (d.h. keine Speicherung, kein Takt).</p>
</section>
</section>
<section id="simulationsmoglichkeiten">
<h2><span class="section-number">5.2. </span>Simulationsmöglichkeiten<a class="headerlink" href="#simulationsmoglichkeiten" title="Link to this heading">¶</a></h2>
<p>Mit SpinalHDL kannst du direkt in Scala simulieren.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Adder</span><span class="p">).</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">7</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">toInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="id1">
<h3><span class="section-number">5.2.1. </span>Erklärung :<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SimConfig.withWave</span></code>: Aktiviert Wellenform-Ausgabe (<code class="docutils literal notranslate"><span class="pre">.vcd</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compile(new</span> <span class="pre">Adder)</span></code>: kompiliert die Adder-Komponente für Simulation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">doSim</span> <span class="pre">{</span> <span class="pre">dut</span> <span class="pre">=&gt;</span> <span class="pre">...</span> <span class="pre">}</span></code>: definiert, was im Simulationslauf passieren soll.</p></li>
</ul>
<p><strong>Innerhalb des Blocks:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dut.io.a</span> <span class="pre">#=</span> <span class="pre">4</span></code>: Setzt Eingang <code class="docutils literal notranslate"><span class="pre">a</span></code> auf 4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dut.io.b</span> <span class="pre">#=</span> <span class="pre">7</span></code>: Setzt Eingang <code class="docutils literal notranslate"><span class="pre">b</span></code> auf 7</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">forkStimulus(10)</span></code>: Erzeugt Taktsignal mit Periodendauer 10</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">waitSampling()</span></code>: Wartet auf eine steigende Taktflanke</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assert(...)</span></code>: Prüft, ob das Ergebnis tatsächlich 11 ist</p></li>
</ul>
<blockquote>
<div><p>Hinweis: Die Simulation verwendet dieselbe Logik wie der Synthese-Code, sie ist somit <strong>cycle-accurate</strong>.</p>
</div></blockquote>
</section>
</section>
<section id="code-generieren-verilog-vhdl">
<h2><span class="section-number">5.3. </span>Code generieren (Verilog/VHDL)<a class="headerlink" href="#code-generieren-verilog-vhdl" title="Link to this heading">¶</a></h2>
<p>Mit einem einfachen Aufruf generierst du RTL-Code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Adder</span><span class="p">)</span>
<span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Adder</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SpinalVerilog(...)</span></code>: erzeugt eine <code class="docutils literal notranslate"><span class="pre">.v</span></code>-Datei (Verilog)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SpinalVhdl(...)</span></code>: erzeugt eine <code class="docutils literal notranslate"><span class="pre">.vhd</span></code>-Datei (VHDL)</p></li>
<li><p>Die Datei enthält exakt das, was von Tools wie <strong>Vivado</strong>, <strong>Quartus</strong>, <strong>Yosys</strong>, etc. verarbeitet werden kann</p></li>
</ul>
<p>Der generierte Code wird im aktuellen Arbeitsverzeichnis gespeichert oft in einem Unterordner wie <code class="docutils literal notranslate"><span class="pre">./rtl/</span></code> oder <code class="docutils literal notranslate"><span class="pre">./simWorkspace/Adder</span></code>.</p>
</section>
<section id="zusammengefasst">
<h2><span class="section-number">5.4. </span>Zusammengefasst:<a class="headerlink" href="#zusammengefasst" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>Ziel</p></th>
<th class="head"><p>Beispiel</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Komponentenbau</p></td>
<td><p>Schaltung entwerfen</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Adder</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Simulation</p></td>
<td><p>Verhalten testen</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">doSim</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Codegenerierung</p></td>
<td><p>Verilog/VHDL für Synthesis</p></td>
<td><p>`SpinalVerilog(…)</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="praxisbeispiele">
<h1><span class="section-number">6. </span>Praxisbeispiele<a class="headerlink" href="#praxisbeispiele" title="Link to this heading">¶</a></h1>
<section id="comparator">
<h2><span class="section-number">6.1. </span>Comparator<a class="headerlink" href="#comparator" title="Link to this heading">¶</a></h2>
<p>Ein Comparator vergleicht zwei Werte (<code class="docutils literal notranslate"><span class="pre">a</span></code> und <code class="docutils literal notranslate"><span class="pre">b</span></code>) und erzeugt Ausgänge für:</p>
<ul class="simple">
<li><p>Gleichheit (<code class="docutils literal notranslate"><span class="pre">equal</span></code>)</p></li>
<li><p>Größer-als (<code class="docutils literal notranslate"><span class="pre">greater</span></code>)</p></li>
<li><p>Kleiner-als (<code class="docutils literal notranslate"><span class="pre">less</span></code>)</p></li>
</ul>
<p><strong>Aufbau des Moduls</strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Comparator</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">equal</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">greater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">less</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">equal</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">greater</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">less</span><span class="w">    </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Was macht das Modul?</strong></p>
<ul class="simple">
<li><p>Es nimmt zwei <code class="docutils literal notranslate"><span class="pre">UInt</span></code>-Eingänge <code class="docutils literal notranslate"><span class="pre">a</span></code> und <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p>Es vergleicht sie in Echtzeit.</p></li>
<li><p>Setzt genau ein Ergebnis-Signal auf <code class="docutils literal notranslate"><span class="pre">true</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">equal</span></code>: wenn <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">greater</span></code>: wenn <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">less</span></code>: wenn <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></li>
</ul>
</li>
</ul>
<p><strong>Testbench: <code class="docutils literal notranslate"><span class="pre">ComparatorSim.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">ComparatorSim</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Comparator</span><span class="p">(</span><span class="mi">4</span><span class="p">)).</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">equal</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span>

<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">7</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">4</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">greater</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span>

<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">8</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">less</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span>

<span class="w">      </span><span class="n">simSuccess</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verilog-Ausgabe: <code class="docutils literal notranslate"><span class="pre">ComparatorVerilog.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">ComparatorVerilog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Comparator</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verwendung</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span>compile
sbt<span class="w"> </span><span class="s2">&quot;runMain ComparatorSim&quot;</span>
sbt<span class="w"> </span><span class="s2">&quot;runMain ComparatorVerilog&quot;</span>
</pre></div>
</div>
<p>Ergebnis: Die Datei <code class="docutils literal notranslate"><span class="pre">Comparator.v</span></code> wird generiert, und die Testbench prüft die Vergleichsfunktionen.</p>
</section>
<hr class="docutils" />
<section id="zahler">
<h2><span class="section-number">6.2. </span>Zähler<a class="headerlink" href="#zahler" title="Link to this heading">¶</a></h2>
<p>Ein Zähler zählt bei jedem Takt um 1 nach oben. Er kann in vielen Anwendungen eingesetzt werden, z. B. als Zeitgeber, Schleifenzähler oder zur Adressierung.</p>
<p><strong>Aufbau des Moduls</strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">reset</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">.</span><span class="n">elsewhen</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">count</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Was macht das Modul?</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">enable</span></code>: Wenn aktiv, zählt der Zähler hoch.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reset</span></code>: Wenn aktiv, wird der Zähler auf 0 gesetzt.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: Der aktuelle Zählerwert.</p></li>
</ul>
<p><strong>Testbench: <code class="docutils literal notranslate"><span class="pre">CounterSim.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">CounterSim</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="mi">4</span><span class="p">)).</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">false</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span>

<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">false</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Zählerwert = </span><span class="si">${</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">toBigInt</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">simSuccess</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verilog-Ausgabe: <code class="docutils literal notranslate"><span class="pre">CounterVerilog.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">CounterVerilog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verwendung</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span>compile
sbt<span class="w"> </span><span class="s2">&quot;runMain CounterSim&quot;</span>
sbt<span class="w"> </span><span class="s2">&quot;runMain CounterVerilog&quot;</span>
</pre></div>
</div>
<p><strong>Ergebnis:</strong>
Die Datei <code class="docutils literal notranslate"><span class="pre">Counter.v</span></code> wird generiert. In der Simulation zählt der Wert bei <code class="docutils literal notranslate"><span class="pre">enable</span> <span class="pre">=</span> <span class="pre">true</span></code> hoch.</p>
</section>
<hr class="docutils" />
<section id="taktteiler-clock-divider">
<h2><span class="section-number">6.3. </span>Taktteiler (Clock Divider)<a class="headerlink" href="#taktteiler-clock-divider" title="Link to this heading">¶</a></h2>
<p>Ein Taktteiler erzeugt aus einem schnellen Eingangstakt einen langsameren Ausgangstakt, indem er Takte zählt und z. B. nur jedes 256. Signal durchlässt.</p>
<p><strong>Aufbau des Moduls</strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ClockDivider</span><span class="p">(</span><span class="n">divisorWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">divisorWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">clkOut</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">msb</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Was macht das Modul?</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">counter</span></code>: Zählt kontinuierlich bei jedem Takt.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msb</span></code>: Der höchste Bitwert des Zählers (Most Significant Bit) wird als geteilter Takt ausgegeben.</p></li>
<li><p><strong>Beispiel</strong>: Bei <code class="docutils literal notranslate"><span class="pre">divisorWidth</span> <span class="pre">=</span> <span class="pre">8</span></code> ergibt sich ein Teiler von 256 (halbe Periode = 128 Takte).</p></li>
</ul>
<p><strong>Testbench: <code class="docutils literal notranslate"><span class="pre">ClockDividerSim.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">ClockDividerSim</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">ClockDivider</span><span class="p">(</span><span class="mi">8</span><span class="p">)).</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Takt </span><span class="si">$</span><span class="n">i</span><span class="s">: clkOut = </span><span class="si">${</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">clkOut</span><span class="p">.</span><span class="n">toBoolean</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">simSuccess</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verilog-Ausgabe: <code class="docutils literal notranslate"><span class="pre">ClockDividerVerilog.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">ClockDividerVerilog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">ClockDivider</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Verwendung</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span>compile
sbt<span class="w"> </span><span class="s2">&quot;runMain ClockDividerSim&quot;</span>
sbt<span class="w"> </span><span class="s2">&quot;runMain ClockDividerVerilog&quot;</span>
</pre></div>
</div>
<p>Das erzeugt:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ClockDivider.v</span></code>: die Verilog-Datei</p></li>
<li><p>und zeigt die Simulation mit <code class="docutils literal notranslate"><span class="pre">clkOut</span></code>, der etwa alle 128 Takte wechselt.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="pwm">
<h2><span class="section-number">6.4. </span>PWM<a class="headerlink" href="#pwm" title="Link to this heading">¶</a></h2>
<p>Dies ist ein einfaches SpinalHDL-Projekt, das ein parametrierbares PWM-Modul (Pulsweitenmodulation) implementiert. Es enthält:</p>
<ul class="simple">
<li><p>eine Hardwarebeschreibung (<code class="docutils literal notranslate"><span class="pre">Pwm.scala</span></code>)</p></li>
<li><p>eine Testbench (<code class="docutils literal notranslate"><span class="pre">PwmSim.scala</span></code>)</p></li>
<li><p>eine Verilog-Ausgabe (<code class="docutils literal notranslate"><span class="pre">PwmVerilog.scala</span></code>)</p></li>
<li><p>und eine verständliche Erklärung des Funktionsprinzips</p></li>
</ul>
<p><strong>Projektstruktur</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pwm-spinalhdl/
├── build.sbt
├── project/
│   └── build.properties
├── src/
│   ├── main/
│   │   └── scala/
│   │       ├── Pwm.scala           ← [1] PWM-Modul
│   │       └── PwmVerilog.scala    ← [3] Verilog-Ausgabe
│   └── test/
│       └── scala/
│           └── PwmSim.scala        ← [2] Simulation
└── README.md
</pre></div>
</div>
<p><strong>Erklärung des PWM-Moduls</strong></p>
<p>Das PWM-Modul erzeugt ein Signal, das schnell zwischen <strong>an (1)</strong> und <strong>aus (0)</strong> wechselt.<br />
Wie lange das Signal „an“ bleibt, hängt vom <strong>Duty-Cycle</strong> ab – einem Eingabewert, der angibt, wie viel Prozent der Zeit das Signal „an“ sein soll.</p>
<p><strong>Aufbau des Moduls</strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Pwm</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">duty</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pwmOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">pwmOut</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">duty</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Was macht das Modul?</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">width</span></code>: Gibt an, wie genau das PWM-Signal sein soll (z. B. 8 Bit → Werte von 0 bis 255).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enable</span></code>: Schaltet das PWM-Signal ein oder aus.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">duty</span></code>: Bestimmt, wie lange das Signal „an“ sein soll (je höher der Wert, desto länger).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">counter</span></code>: Zählt von 0 bis zum Maximalwert und beginnt dann wieder von vorn.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pwmOut</span></code>: Wird „an“, solange <code class="docutils literal notranslate"><span class="pre">counter</span> <span class="pre">&lt;</span> <span class="pre">duty</span></code>.</p></li>
</ul>
<section id="beispiel-bei-8-bit-auflosung">
<h3><span class="section-number">6.4.1. </span>Beispiel (bei 8 Bit Auflösung)<a class="headerlink" href="#beispiel-bei-8-bit-auflosung" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">duty</span> <span class="pre">=</span> <span class="pre">0</span></code> → Signal ist immer aus</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">duty</span> <span class="pre">=</span> <span class="pre">128</span></code> → Signal ist 50 % der Zeit an</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">duty</span> <span class="pre">=</span> <span class="pre">255</span></code> → Signal ist immer an</p></li>
</ul>
<p>Das Modul vergleicht einen Zähler mit einem Zielwert (<code class="docutils literal notranslate"><span class="pre">duty</span></code>).<br />
Solange der Zähler kleiner ist, ist das Signal <strong>an</strong>  danach <strong>aus</strong>.<br />
Dieser Zyklus wiederholt sich ständig.</p>
<p><strong>[1] <code class="docutils literal notranslate"><span class="pre">src/main/scala/Pwm.scala</span></code> (Code wie oben)</strong></p>
<p>Siehe oben unter „Aufbau des Moduls“.</p>
<p><strong>[2] <code class="docutils literal notranslate"><span class="pre">src/test/scala/PwmSim.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">PwmSim</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SimConfig</span>
<span class="w">      </span><span class="p">.</span><span class="n">withWave</span>
<span class="w">      </span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Pwm</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">// 8-Bit PWM</span>
<span class="w">      </span><span class="p">.</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">duty</span><span class="w">   </span><span class="o">#=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="c1">// 50% Duty Cycle</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cycle</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">simSuccess</span><span class="p">()</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">[3]PwmVerilog.scala</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">PwmVerilog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Pwm</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">build.sbt</span></code></strong></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;pwm-spinalhdl&quot;</span>

<span class="n">version</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;0.1&quot;</span>

<span class="n">scalaVersion</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;2.13.12&quot;</span>

<span class="n">libraryDependencies</span><span class="w"> </span><span class="o">++=</span><span class="w"> </span><span class="nc">Seq</span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;com.github.spinalhdl&quot;</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="s">&quot;spinalhdl-core&quot;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="s">&quot;1.9.1&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="s">&quot;com.github.spinalhdl&quot;</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="s">&quot;spinalhdl-sim&quot;</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="s">&quot;1.9.1&quot;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nc">Test</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Projekt kompilieren und starten</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span>compile
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span><span class="s2">&quot;runMain PwmVerilog&quot;</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sbt<span class="w"> </span><span class="s2">&quot;runMain PwmSim&quot;</span>
</pre></div>
</div>
<p><strong>Ergebnis</strong></p>
<ul class="simple">
<li><p>Wir erhalten ein synthetisierbares PWM-Modul</p></li>
<li><p>Wir können das Verhalten direkt simulieren</p></li>
<li><p>Der generierte Verilog-Code (<code class="docutils literal notranslate"><span class="pre">Pwm.v</span></code>) ist für FPGA/ASIC verwendbar</p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">SpinalHDL</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Einleitung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#motivation">1.1. Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uberblick-uber-traditionelle-hdls-vhdl-verilog">1.2. Überblick über traditionelle HDLs (VHDL/Verilog)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#warum-die-abkehr-sinnvoll-ist">1.3. Warum die Abkehr sinnvoll ist</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#grundlagen-von-spinalhdl">2. Grundlagen von SpinalHDL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variablendeklaration-in-spinalhdl">2.1. Variablendeklaration in SpinalHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signale-vs-register">2.2. Signale vs. Register</a></li>
<li class="toctree-l2"><a class="reference internal" href="#steuerstrukturen">2.3. Steuerstrukturen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bundles-schnittstellen">2.4. Bundles (Schnittstellen)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vektoren-und-arrays">2.5. Vektoren und Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#komponentenstruktur">2.6. Komponentenstruktur</a></li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-mit-verilog-ausgabe">2.7. Top-Level mit Verilog-Ausgabe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typisches-verhalten-vs-vhdl">2.8. Typisches Verhalten vs. VHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#besonderheiten">2.9. Besonderheiten</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tl-dr-fur-anfanger">2.10. TL;DR für Anfänger</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#struktur-und-aufbau-eines-spinalhdl-projekts">3. Struktur und Aufbau eines SpinalHDL-Projekts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ordnerstruktur">3.1. Ordnerstruktur</a></li>
<li class="toctree-l2"><a class="reference internal" href="#entwicklungsumgebung">3.2. Entwicklungsumgebung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beispiel-kommando">3.3. Beispiel-Kommando</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#vorteile-von-spinalhdl-gegenuber-traditionellen-hdls">4. Vorteile von SpinalHDL gegenüber traditionellen HDLs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#syntax-und-typsicherheit">4.1. Syntax und Typsicherheit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abstraktion-und-wiederverwendbarkeit">4.2. Abstraktion und Wiederverwendbarkeit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fehlerdiagnose">4.3. Fehlerdiagnose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation-debugging">4.4. Simulation &amp; Debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#entwicklungsworkflow">5. Entwicklungsworkflow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#komponentenbeschreibung">5.1. Komponentenbeschreibung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulationsmoglichkeiten">5.2. Simulationsmöglichkeiten</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-generieren-verilog-vhdl">5.3. Code generieren (Verilog/VHDL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#zusammengefasst">5.4. Zusammengefasst:</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#praxisbeispiele">6. Praxisbeispiele</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#comparator">6.1. Comparator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#zahler">6.2. Zähler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#taktteiler-clock-divider">6.3. Taktteiler (Clock Divider)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pwm">6.4. PWM</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to SpinalHDL Documention</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Bakr Aassoul.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/spinalHDL.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>